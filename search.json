[
  {
    "objectID": "mcu.html",
    "href": "mcu.html",
    "title": "Bode Plot Generator",
    "section": "",
    "text": "The primary MCU function is for reading in the data from the DUT and the communication system and processing and plotting the data on the ESP8266 webserver in a bode plot form with gain [dB] and phase [degrees]. To perform the DAQ over a range of frequencies the MCU and FPGA communicate over a set of digital pins performing simple active high handshakes to move along a system FSM. The analog data is read off of an ADC pin continuously polling values at 12 bits of resolution every 24.5 clock cycles.\n\n\n\n\n\nFigure 1: System flow chart for the main MCU function with interrupt handler EXTI9_5\n\n\nFigure 1 displays the sequence of operations on a given MCU reset or bode plot DAQ protocol and display. First a configuration sequence is run, enabling necessary peripherals, GPIO pins, clock, and and flash. For this project we chose to run the PLL through the SYSCLK at 80MHz to achieve optimal instruction execution time as we had a few key timing aspects of this project.\nThe GPIO pins fall into two main categories; input and output pins for the communication link between the MCU and FPGA and the ADC analog input. The input pin function and detailed outline can be found in the System section. The pinouts for the MCU pins can be found in Figure 2 below.\n\n\n\nMCU\nLabel\n\n\n\n\nPA8\nMCO (clk)\n\n\nPA11\nFULL_WAVE\n\n\nPA12\nMCU_READY\n\n\nPB5\nSWEEP_DONE\n\n\nPB4\nHALF_WAVE\n\n\nPB6\nINIT_BODE\n\n\nPA6\nZERO_CROSS\n\n\nPA0\nMCU_DONE\n\n\nPA2\nGPIO_ADC\n\n\nPB3\nGPIO_LED (Debugging)\n\n\n\nAll pins except PA2 and PB3 fall into the communication link category of pins. The MCU drives the FPGA at a reduced clock rate of 10MHz through the MCO pin which is the largest possible frequency that our bread board wiring could support without coupling and degradation of the wave.\nMCU_READY and MCU_DONE were GPIO outputs that told the FPGA that the MCU had either finished initialization or finished the ADC conversions and extraction of phase and gain. ZERO_CROSS was an active high flag used to send RX zero crossing timings from the FPGA to the MCU. INIT_BODE, SWEEP_DONE, FULLWAVE, and HALF WAVE are used for initialization and starting and stopping the frequency sweep. GPIO_ADC operates depending on the state of the other pins and polls data from the ADC peripheral at a high rate.\nThe new MCU feature that we used for this project was the ADC peripheral on the STM32L432KC. While the E155 labs covered peripherals such as timers and SPI we did not talk about or work with the ADC peripheral. This peripheral allows special function GPIO pins to be routed to the inputs of the ADC and convert analog voltages to digital bits. We chose to implement the peripheral in single conversion mode that, when toggled, could sample the incoming sine wave at a high enough frequency as to abide by the Nyquist Theorem.\n\\[ 2*fmax &lt; fs \\]\nWe determined experimentally that our sampling rate was roughly 900kHz by inputting a square wave with a function generator with a known frequency and duty cycle. Then by counting the samples between periods, a relatively accurate estimate of the sample rate was obtained. Given that our max carrier frequency was 100kHz we were sampling at a high enough frequency to properly extract gain and phase.\nThis design uses the ADC peripheral in order to convert analog signals comming from our DUT into digital signals.\n\n\n\nThe data collection sequence was split into two sections, one for each of the types of data that we were collecting; gain and phase.\n\n\n\n\nFirst, the ADC peripheral was polled for a predetermined number of samples. It was important that we had enough samples to meet our lowest carrier frequency of 100 hz. Given our sample rate of 900 MHz and the period of the wave being 10ms we would be able to sample on average 1.11 periods of the signal. This was sufficient to see two peaks and at least one falling edge zero crossing therefore effectively extracting the necessary data. Once the amplitude data was stored and extracted, we converted it immediately to gain so we could re-use the allocated memory on the next iteration of the frequency spectrum. We hard coded the input amplitude value based on a manual calibration during development.\n\n\n\nThe phase extraction process was similar but had more detailed DAQ parameters due to the need to track timing differences between events. In order to extract the phase TX and RX falling edge zero crossings were detected and compared in time. To track time we had a simple general purpose timer free running, when a falling edge was detected at either TX or RX the counter value was sampled.\nThe FPGA sent TX zero crossing flags at every rising edge however, the signal was inverted through a necessary inverting op amp with a gain &lt;1 meaning the zero crossing would land on Rising edges. To detect these we implemented a GPIO EXTI interrupt that would trip and sample the timer counter value. To detect RX zero crossings we implemented a simple analog watchdog algorithm to watch the continuously polling ADC for a threshold value. Once a specified number of zero crossings had been detected, the interrupt was disabled and the phase difference between the zero crossings was calculated.\nWe ran into many issues with this section as we could never sample the same zero crossing due to the interrupt handler’s run time crowding the RX zero crossing at high frequencies. Our algorithm instead continuously wrapped the phase to be in the 180 to -180 range accounting for the zero crossings existing on different periods of the carrier wave. It was determined experimentally that the optimal number of zero crossings to sample was 2. Any more and the 100Hz signal would trigger on the overflow of the counter value and the time difference would be difficult to extract.\n\n\nOnce the gain and phase data had been acquired and converted to the correct units we converted them to strings using the sprintf function so they could be sent over a USART link to an ESP8266 wifi module. To plot the data itself we used the canvas API in HTML. This allowed us to create a log plotting function that would take the data and known frequency table and plot them on a log scale."
  },
  {
    "objectID": "mcu.html#mcu",
    "href": "mcu.html#mcu",
    "title": "Bode Plot Generator",
    "section": "",
    "text": "The primary MCU function is for reading in the data from the DUT and the communication system and processing and plotting the data on the ESP8266 webserver in a bode plot form with gain [dB] and phase [degrees]. To perform the DAQ over a range of frequencies the MCU and FPGA communicate over a set of digital pins performing simple active high handshakes to move along a system FSM. The analog data is read off of an ADC pin continuously polling values at 12 bits of resolution every 24.5 clock cycles.\n\n\n\n\n\nFigure 1: System flow chart for the main MCU function with interrupt handler EXTI9_5\n\n\nFigure 1 displays the sequence of operations on a given MCU reset or bode plot DAQ protocol and display. First a configuration sequence is run, enabling necessary peripherals, GPIO pins, clock, and and flash. For this project we chose to run the PLL through the SYSCLK at 80MHz to achieve optimal instruction execution time as we had a few key timing aspects of this project.\nThe GPIO pins fall into two main categories; input and output pins for the communication link between the MCU and FPGA and the ADC analog input. The input pin function and detailed outline can be found in the System section. The pinouts for the MCU pins can be found in Figure 2 below.\n\n\n\nMCU\nLabel\n\n\n\n\nPA8\nMCO (clk)\n\n\nPA11\nFULL_WAVE\n\n\nPA12\nMCU_READY\n\n\nPB5\nSWEEP_DONE\n\n\nPB4\nHALF_WAVE\n\n\nPB6\nINIT_BODE\n\n\nPA6\nZERO_CROSS\n\n\nPA0\nMCU_DONE\n\n\nPA2\nGPIO_ADC\n\n\nPB3\nGPIO_LED (Debugging)\n\n\n\nAll pins except PA2 and PB3 fall into the communication link category of pins. The MCU drives the FPGA at a reduced clock rate of 10MHz through the MCO pin which is the largest possible frequency that our bread board wiring could support without coupling and degradation of the wave.\nMCU_READY and MCU_DONE were GPIO outputs that told the FPGA that the MCU had either finished initialization or finished the ADC conversions and extraction of phase and gain. ZERO_CROSS was an active high flag used to send RX zero crossing timings from the FPGA to the MCU. INIT_BODE, SWEEP_DONE, FULLWAVE, and HALF WAVE are used for initialization and starting and stopping the frequency sweep. GPIO_ADC operates depending on the state of the other pins and polls data from the ADC peripheral at a high rate.\nThe new MCU feature that we used for this project was the ADC peripheral on the STM32L432KC. While the E155 labs covered peripherals such as timers and SPI we did not talk about or work with the ADC peripheral. This peripheral allows special function GPIO pins to be routed to the inputs of the ADC and convert analog voltages to digital bits. We chose to implement the peripheral in single conversion mode that, when toggled, could sample the incoming sine wave at a high enough frequency as to abide by the Nyquist Theorem.\n\\[ 2*fmax &lt; fs \\]\nWe determined experimentally that our sampling rate was roughly 900kHz by inputting a square wave with a function generator with a known frequency and duty cycle. Then by counting the samples between periods, a relatively accurate estimate of the sample rate was obtained. Given that our max carrier frequency was 100kHz we were sampling at a high enough frequency to properly extract gain and phase.\nThis design uses the ADC peripheral in order to convert analog signals comming from our DUT into digital signals.\n\n\n\nThe data collection sequence was split into two sections, one for each of the types of data that we were collecting; gain and phase.\n\n\n\n\nFirst, the ADC peripheral was polled for a predetermined number of samples. It was important that we had enough samples to meet our lowest carrier frequency of 100 hz. Given our sample rate of 900 MHz and the period of the wave being 10ms we would be able to sample on average 1.11 periods of the signal. This was sufficient to see two peaks and at least one falling edge zero crossing therefore effectively extracting the necessary data. Once the amplitude data was stored and extracted, we converted it immediately to gain so we could re-use the allocated memory on the next iteration of the frequency spectrum. We hard coded the input amplitude value based on a manual calibration during development.\n\n\n\nThe phase extraction process was similar but had more detailed DAQ parameters due to the need to track timing differences between events. In order to extract the phase TX and RX falling edge zero crossings were detected and compared in time. To track time we had a simple general purpose timer free running, when a falling edge was detected at either TX or RX the counter value was sampled.\nThe FPGA sent TX zero crossing flags at every rising edge however, the signal was inverted through a necessary inverting op amp with a gain &lt;1 meaning the zero crossing would land on Rising edges. To detect these we implemented a GPIO EXTI interrupt that would trip and sample the timer counter value. To detect RX zero crossings we implemented a simple analog watchdog algorithm to watch the continuously polling ADC for a threshold value. Once a specified number of zero crossings had been detected, the interrupt was disabled and the phase difference between the zero crossings was calculated.\nWe ran into many issues with this section as we could never sample the same zero crossing due to the interrupt handler’s run time crowding the RX zero crossing at high frequencies. Our algorithm instead continuously wrapped the phase to be in the 180 to -180 range accounting for the zero crossings existing on different periods of the carrier wave. It was determined experimentally that the optimal number of zero crossings to sample was 2. Any more and the 100Hz signal would trigger on the overflow of the counter value and the time difference would be difficult to extract.\n\n\nOnce the gain and phase data had been acquired and converted to the correct units we converted them to strings using the sprintf function so they could be sent over a USART link to an ESP8266 wifi module. To plot the data itself we used the canvas API in HTML. This allowed us to create a log plotting function that would take the data and known frequency table and plot them on a log scale."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About the Team",
    "section": "",
    "text": "George Davis is a Senior Engineering student at Harvey Mudd College from Seattle, Washington. He is interested in electrical design including analog, RF, and digital circuits. In his free time, George loves to play the drums, go on hikes, and spend time with his friends in anyway possible. His interest in engineering started with robotics but now with what he has learned at HMC he has the skills to apply himself to many different subjects!\nGitHub\nLinkedIn\n\n\n\nMatthew Molinar is a Senior Engineering student at Harvey Mudd College. His interests are in the field of electrical engineering, with a particular focus on RF and digital signal processing. In his free time, Matthew loves to play basketball, spend time with friends, and look for new music to listen to.\nGitHub\nLinkedIn"
  },
  {
    "objectID": "about.html#team",
    "href": "about.html#team",
    "title": "About the Team",
    "section": "",
    "text": "George Davis is a Senior Engineering student at Harvey Mudd College from Seattle, Washington. He is interested in electrical design including analog, RF, and digital circuits. In his free time, George loves to play the drums, go on hikes, and spend time with his friends in anyway possible. His interest in engineering started with robotics but now with what he has learned at HMC he has the skills to apply himself to many different subjects!\nGitHub\nLinkedIn\n\n\n\nMatthew Molinar is a Senior Engineering student at Harvey Mudd College. His interests are in the field of electrical engineering, with a particular focus on RF and digital signal processing. In his free time, Matthew loves to play basketball, spend time with friends, and look for new music to listen to.\nGitHub\nLinkedIn"
  },
  {
    "objectID": "about.html#acknowledgments",
    "href": "about.html#acknowledgments",
    "title": "About the Team",
    "section": "Acknowledgments",
    "text": "Acknowledgments\nWe would like to give a big thanks to Prof. Spencer for helping us think through the implementation of this project. We’d also like to thank all the course grutors and our peers for their support."
  },
  {
    "objectID": "fpga.html",
    "href": "fpga.html",
    "title": "Bode Plot Generator",
    "section": "",
    "text": "The iCE40 FPGA generates a sine wave using an internally implemented Direct Digital Synthesizer (DDS). As a part of the DDS implementation, the FPGA stores a quarter-wave sine table in non volatile Flash Read Only Memory (ROM), which is a new feature we used for our FPGA. The DDS generates sine waves at various frequencies to preform a frequency sweep from (100 Hz to 100 kHz), which will then drive a DAC to make an analog signal.\nThe Flash ROM was used as a way to store a sine wave LUT in non-volatile storage with immediate access. This feature goes beyond the previous material covered in the course because in the past we were concerned about optimizing a design for space by minimizing the number of LUT’s used. Thus, using the Flash ROM feature addresses this concern in a new way because it avoids storing data through the use of LUT’s. Ultimately, by using Flash ROM, we were able to keep a super light weight design by using only 5 % of the onboard LUT’s.\n\n\n\n\n\nThe FPGA is responsible for creating a frequency sweep that drives an external parallel 8-bit DAC. To do this, the FPGA generates a frequency sweep using a DDS. More specifically, we opted for a quarter-wave DDS, which only requires a fourth of a full sine wave table, in order to save on memory. This table was stored on the FPGA using its Flash ROM.\nThe sweep control FSM (see figure 1) on the FPGA is responsible for generating a frequency sweep for our desired range (100 Hz to 100 kHz). The MCU controls this FSM by sending various flags to the FPGA, which lets it know when it should start a new process. To illustrate, the MCU lets the FPGA know when it’s ready to collect data for the current frequency and when its done collecting data, which serves as a flag for the FPGA to know when to start generating a wave at a specific frequency, and when to move on to the next wave.\n\n\n\nFigure 1: FSM Diagram for the Sweep Controller\n\n\n\nThe second FSM present in the bode interface module is responsible for sending important information to the MCU via flags. The FPGA notifies the MCU when there is a zero crossing on its end, which amplitude attenuation mode it’s in, and when it is done sweeping frequencies.\n\n\n\nFigure 2: FSM Diagram for the Bode Interface\n\n\n\nThe source code for the FPGA can be found here.\n\n\n\nTesting for the FPGA was done by doing simulations for each individual submodule. Then, a testbench was created for the top module, which ensured that all modules interacted together accurately. Then, we verified that the design was actually behaving as we expected in physical hardware. Once we set up the interface with the external DAC, we watched the signal on an osccilloscope and made sure the sine waves were being generated at the correct frequency.\n\n\n\n\n\n\nFPGA\nLabel\n\n\n\n\nP19\nMCO (clk)\n\n\nP20\nFULL_WAVE_OUT\n\n\nP11\nMCU_READY\n\n\nP10\nSWEEP_DONE\n\n\nP12\nHALF_WAVE_OUT\n\n\nP18\nINIT_BODE\n\n\nP27\nZERO_CROSS\n\n\nP13\nMCU_DONE\n\n\nP9\nSystem Reset\n\n\nP3\nDAC_DATA0\n\n\nP45\nDAC_DATA1\n\n\nP46\nDAC_DATA2\n\n\nP6\nDAC_DATA3\n\n\nP4\nDAC_DATA4\n\n\nP48\nDAC_DATA5\n\n\nP47\nDAC_DATA6\n\n\nP2\nDAC_DATA7\n\n\nP44\nDAC_WR\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Waveforms from top module simulation\n\n\n\n\n\n\nFigure 4: Waveforms from sweep controller simulation\n\n\n\nThe design met the intended design objectives. Figure 3 shows that the FPGA is able to generate input data for the DAC and communicate with the MCU via the exchange of various flags. Figure 4, shows that the FPGA can generate a frequency sweep of sine waves. Here, the digital signal output from the DDS visualized as an analog signal.\nSimulation / waveform images of our testbenches passing can be found here.\n\n\n\nTo test this design with hardware we used a logic analyzer and an oscillscope. Using these instruments allowed us to verify that flags from the FPGA were being raised at the right time. It also allowed us to verify that the sine waves being generated had the correct frequency. In Figure 6, we can see the digital signals (D0 - D7) that were driving the DAC. Additionally, D9 shows the FPGA tracking falling edge zero crossings. This flag is being sent to the MCU to let it know when it sees zero crossing on its end.\n\n\n\n\nFigure 5: Oscilloscope trace of frequency sweep\n\n\n\n\n\n\nFigure 6: Logic Analyzer displaying digital signals overlayed with the analog signal\n\n\n\n\n\n\n\nThis design sucessfully implemented a quarter-wave DDS, which creates sine waves at multiple frequencies that will drive an external DAC. It also used handsahke logic via flags to communicate with the MCU to ensure that state transitions were timed accordingly. As apart of its communication with the MCU, the FPGA sent flags to let the MCU know when a zero crossing was detected, what amplitdue state it was in, and when the frequency sweep was done."
  },
  {
    "objectID": "fpga.html#fpga",
    "href": "fpga.html#fpga",
    "title": "Bode Plot Generator",
    "section": "",
    "text": "The iCE40 FPGA generates a sine wave using an internally implemented Direct Digital Synthesizer (DDS). As a part of the DDS implementation, the FPGA stores a quarter-wave sine table in non volatile Flash Read Only Memory (ROM), which is a new feature we used for our FPGA. The DDS generates sine waves at various frequencies to preform a frequency sweep from (100 Hz to 100 kHz), which will then drive a DAC to make an analog signal.\nThe Flash ROM was used as a way to store a sine wave LUT in non-volatile storage with immediate access. This feature goes beyond the previous material covered in the course because in the past we were concerned about optimizing a design for space by minimizing the number of LUT’s used. Thus, using the Flash ROM feature addresses this concern in a new way because it avoids storing data through the use of LUT’s. Ultimately, by using Flash ROM, we were able to keep a super light weight design by using only 5 % of the onboard LUT’s.\n\n\n\n\n\nThe FPGA is responsible for creating a frequency sweep that drives an external parallel 8-bit DAC. To do this, the FPGA generates a frequency sweep using a DDS. More specifically, we opted for a quarter-wave DDS, which only requires a fourth of a full sine wave table, in order to save on memory. This table was stored on the FPGA using its Flash ROM.\nThe sweep control FSM (see figure 1) on the FPGA is responsible for generating a frequency sweep for our desired range (100 Hz to 100 kHz). The MCU controls this FSM by sending various flags to the FPGA, which lets it know when it should start a new process. To illustrate, the MCU lets the FPGA know when it’s ready to collect data for the current frequency and when its done collecting data, which serves as a flag for the FPGA to know when to start generating a wave at a specific frequency, and when to move on to the next wave.\n\n\n\nFigure 1: FSM Diagram for the Sweep Controller\n\n\n\nThe second FSM present in the bode interface module is responsible for sending important information to the MCU via flags. The FPGA notifies the MCU when there is a zero crossing on its end, which amplitude attenuation mode it’s in, and when it is done sweeping frequencies.\n\n\n\nFigure 2: FSM Diagram for the Bode Interface\n\n\n\nThe source code for the FPGA can be found here.\n\n\n\nTesting for the FPGA was done by doing simulations for each individual submodule. Then, a testbench was created for the top module, which ensured that all modules interacted together accurately. Then, we verified that the design was actually behaving as we expected in physical hardware. Once we set up the interface with the external DAC, we watched the signal on an osccilloscope and made sure the sine waves were being generated at the correct frequency.\n\n\n\n\n\n\nFPGA\nLabel\n\n\n\n\nP19\nMCO (clk)\n\n\nP20\nFULL_WAVE_OUT\n\n\nP11\nMCU_READY\n\n\nP10\nSWEEP_DONE\n\n\nP12\nHALF_WAVE_OUT\n\n\nP18\nINIT_BODE\n\n\nP27\nZERO_CROSS\n\n\nP13\nMCU_DONE\n\n\nP9\nSystem Reset\n\n\nP3\nDAC_DATA0\n\n\nP45\nDAC_DATA1\n\n\nP46\nDAC_DATA2\n\n\nP6\nDAC_DATA3\n\n\nP4\nDAC_DATA4\n\n\nP48\nDAC_DATA5\n\n\nP47\nDAC_DATA6\n\n\nP2\nDAC_DATA7\n\n\nP44\nDAC_WR\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Waveforms from top module simulation\n\n\n\n\n\n\nFigure 4: Waveforms from sweep controller simulation\n\n\n\nThe design met the intended design objectives. Figure 3 shows that the FPGA is able to generate input data for the DAC and communicate with the MCU via the exchange of various flags. Figure 4, shows that the FPGA can generate a frequency sweep of sine waves. Here, the digital signal output from the DDS visualized as an analog signal.\nSimulation / waveform images of our testbenches passing can be found here.\n\n\n\nTo test this design with hardware we used a logic analyzer and an oscillscope. Using these instruments allowed us to verify that flags from the FPGA were being raised at the right time. It also allowed us to verify that the sine waves being generated had the correct frequency. In Figure 6, we can see the digital signals (D0 - D7) that were driving the DAC. Additionally, D9 shows the FPGA tracking falling edge zero crossings. This flag is being sent to the MCU to let it know when it sees zero crossing on its end.\n\n\n\n\nFigure 5: Oscilloscope trace of frequency sweep\n\n\n\n\n\n\nFigure 6: Logic Analyzer displaying digital signals overlayed with the analog signal\n\n\n\n\n\n\n\nThis design sucessfully implemented a quarter-wave DDS, which creates sine waves at multiple frequencies that will drive an external DAC. It also used handsahke logic via flags to communicate with the MCU to ensure that state transitions were timed accordingly. As apart of its communication with the MCU, the FPGA sent flags to let the MCU know when a zero crossing was detected, what amplitdue state it was in, and when the frequency sweep was done."
  },
  {
    "objectID": "system.html",
    "href": "system.html",
    "title": "Bode Plot Generator",
    "section": "",
    "text": "This section details the communication that occurrs between the FPGA and the MCU, accompanied by a system level blcok diagram and system level schematics.\nIt also details the many analog considerations we had to account for in order to properly transer signals between the FPGA, DAC, DUT, and MCU.\n\n\n\nOur system is composed of an FPGA, an MCU, and an ESP8266. The FPGA is controlled by the MCU and is responsible for generating a sine wave frequency sweep from 100 Hz to 100 kHz. This frequency sweep drives an external DAC (AD5424), which outputs an analog signal that passes through a transmit chain, then a DUT (filter of choice), and through the receive chain. The MCU then uses its ADC peripheral to collect data throughout the frequency sweep in order to calculate the magnitude and phase responses as a result of the DUT. Finally, the MCU sends this data to an ESP8266 which hosts a webpage containing the bode plots that characterize the selected DUT.\n\n\n\n\n\n\nFigure 1: System Block Diagram for Bode Plot Generator\n\n\n\n\n\n\n\n\nFigure 2: System level Schematic for Bode Plot Generator\n\n\n\n\n\n\nFigure 3: TX Chain Schematic\n\n\n\n\n\n\nFigure 4: RX Chain Schematic\n\n\n\n\n\nThe new hardware we used was an AD5424, which is an 8-bit parallel DAC. We chose this DAC because it had a large update rate (20.4 MSPS) and a good multiplying bandwidth (10 MHz). The FPGA drives this DAC with parallel digital signals that represnt a sine wave, which is then converted into an anlog signal by the DAC. We needed this signal to be anlog so that it can be passed through our DUT and be picked up by the ADC thats onboard the MCU. This DAC is a current source which lead to a number of analog op amp considerations.\n\n\n\nThe primary analog considerations were noise reduction and op amp scaling to meet the input voltage range of the MCU. Two chains of op-amps were created using the TL084CN op-amp with a sufficient Gain Bandwidth Product of 5.25Mhz and a fast slew rate of 20V per microsecond.\nThe TX chain or transmit chain place the analog DAC output on a zero centered wave between -1.65 and 1.65 volts. We were able to do this accurately with a coupling circuit and inverting amplifier with gain. To limit noise we added decoupling capacitors to all op-amp rails. After we implemented this we saw a significant increase in our signal to noise ratio at large attenuation. Unity gain buffers were used liberally to ensure buffered impedance between sections of the circuit.\nThe RX chain needed to scale the received signal to the MCU input voltage range of 0 to 3.3V. We used a simple summing op amp with buffer to bring the wave from zero centered to the center of the input range."
  },
  {
    "objectID": "system.html#system-integration",
    "href": "system.html#system-integration",
    "title": "Bode Plot Generator",
    "section": "",
    "text": "This section details the communication that occurrs between the FPGA and the MCU, accompanied by a system level blcok diagram and system level schematics.\nIt also details the many analog considerations we had to account for in order to properly transer signals between the FPGA, DAC, DUT, and MCU.\n\n\n\nOur system is composed of an FPGA, an MCU, and an ESP8266. The FPGA is controlled by the MCU and is responsible for generating a sine wave frequency sweep from 100 Hz to 100 kHz. This frequency sweep drives an external DAC (AD5424), which outputs an analog signal that passes through a transmit chain, then a DUT (filter of choice), and through the receive chain. The MCU then uses its ADC peripheral to collect data throughout the frequency sweep in order to calculate the magnitude and phase responses as a result of the DUT. Finally, the MCU sends this data to an ESP8266 which hosts a webpage containing the bode plots that characterize the selected DUT.\n\n\n\n\n\n\nFigure 1: System Block Diagram for Bode Plot Generator\n\n\n\n\n\n\n\n\nFigure 2: System level Schematic for Bode Plot Generator\n\n\n\n\n\n\nFigure 3: TX Chain Schematic\n\n\n\n\n\n\nFigure 4: RX Chain Schematic\n\n\n\n\n\nThe new hardware we used was an AD5424, which is an 8-bit parallel DAC. We chose this DAC because it had a large update rate (20.4 MSPS) and a good multiplying bandwidth (10 MHz). The FPGA drives this DAC with parallel digital signals that represnt a sine wave, which is then converted into an anlog signal by the DAC. We needed this signal to be anlog so that it can be passed through our DUT and be picked up by the ADC thats onboard the MCU. This DAC is a current source which lead to a number of analog op amp considerations.\n\n\n\nThe primary analog considerations were noise reduction and op amp scaling to meet the input voltage range of the MCU. Two chains of op-amps were created using the TL084CN op-amp with a sufficient Gain Bandwidth Product of 5.25Mhz and a fast slew rate of 20V per microsecond.\nThe TX chain or transmit chain place the analog DAC output on a zero centered wave between -1.65 and 1.65 volts. We were able to do this accurately with a coupling circuit and inverting amplifier with gain. To limit noise we added decoupling capacitors to all op-amp rails. After we implemented this we saw a significant increase in our signal to noise ratio at large attenuation. Unity gain buffers were used liberally to ensure buffered impedance between sections of the circuit.\nThe RX chain needed to scale the received signal to the MCU input voltage range of 0 to 3.3V. We used a simple summing op amp with buffer to bring the wave from zero centered to the center of the input range."
  },
  {
    "objectID": "demo.html",
    "href": "demo.html",
    "title": "Bode Plot Generator",
    "section": "",
    "text": "Figure 1: Generated Bode Plots for LPF\n\n\n\nFigure 1 shows bode plots generated from a low pass filter. We can see the gain go from about 0 to -26 dB with a corner frequency at about 1 kHz.\n\n\n\nFigure 2: Generated Bode Plots for HPF\n\n\n\nFigure 2 shows bode plots generated from a high pass filter. We can see the gain go from about -22 dB to about 0 dB with a corner frequency at about 1 kHz.\n\n\n\nFigure 3: Generated Bode Plots for just a wire\n\n\n\nFigure 3 shows bode plots generated from just a thorugh wire. We can see the gain stay right around 0 which is what we would eexpect.\n\n\n\nFigure 4: Picture of our breadboard\n\n\n\n\n\nUltimately, we were able use the FPGA to drive an external DAC with a sine wave frequency sweep. The frequency sweep accurately ranged from 100 Hz to 100 kHz in order to cover three decades of information for the bode plot. We were also able to sample data using the MCU up to a frequency of 1 MHz. Finally, we were able to generate and display relatively accurate bode plots on a webpage. The gain is very consistent and is able to plot -20dB well for a simple first order filter. The phase struggles to keep up at high frequencies and is prone to outliers. However as seen in Figure 4, when connected to the through or wire with zero load the phase is very close to zero. As frequency increases the variability or error increases as the period of the wave decreases giving the phase extraction algorithm less time to react and sources of error such as propogation delay due to the instruction processing time impact the calculation more. Past 1 kHz the phase degrades to about 17% to 30% error on data points that are not outliers."
  },
  {
    "objectID": "demo.html#demo-and-results",
    "href": "demo.html#demo-and-results",
    "title": "Bode Plot Generator",
    "section": "",
    "text": "Figure 1: Generated Bode Plots for LPF\n\n\n\nFigure 1 shows bode plots generated from a low pass filter. We can see the gain go from about 0 to -26 dB with a corner frequency at about 1 kHz.\n\n\n\nFigure 2: Generated Bode Plots for HPF\n\n\n\nFigure 2 shows bode plots generated from a high pass filter. We can see the gain go from about -22 dB to about 0 dB with a corner frequency at about 1 kHz.\n\n\n\nFigure 3: Generated Bode Plots for just a wire\n\n\n\nFigure 3 shows bode plots generated from just a thorugh wire. We can see the gain stay right around 0 which is what we would eexpect.\n\n\n\nFigure 4: Picture of our breadboard\n\n\n\n\n\nUltimately, we were able use the FPGA to drive an external DAC with a sine wave frequency sweep. The frequency sweep accurately ranged from 100 Hz to 100 kHz in order to cover three decades of information for the bode plot. We were also able to sample data using the MCU up to a frequency of 1 MHz. Finally, we were able to generate and display relatively accurate bode plots on a webpage. The gain is very consistent and is able to plot -20dB well for a simple first order filter. The phase struggles to keep up at high frequencies and is prone to outliers. However as seen in Figure 4, when connected to the through or wire with zero load the phase is very close to zero. As frequency increases the variability or error increases as the period of the wave decreases giving the phase extraction algorithm less time to react and sources of error such as propogation delay due to the instruction processing time impact the calculation more. Past 1 kHz the phase degrades to about 17% to 30% error on data points that are not outliers."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bode Plot Generator",
    "section": "",
    "text": "This project will implement an interactive Bode plot generator, which will be capable of displaying the amplitude and phase response of a device under test (DUT) across a swept frequency range. This will be implemented using an FPGA to generate sine waves via an internal DDS, and an MCU to receive and process the signal. Then, the data is sent from the MCU to an ESP8266, which will host a webpage for plotting the Bode plot."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Bode Plot Generator Resources",
    "section": "",
    "text": "E155 Course Website\nGitHub\nData Sheets"
  }
]